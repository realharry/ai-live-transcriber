import { useState, useEffect } from 'react'
import { Button } from '@/components/ui/button'
import { Select } from '@/components/ui/select'
import { Textarea } from '@/components/ui/textarea'
import { useAudioRecording } from '@/hooks/useAudioRecording'
import { downloadTextAsFile, formatTimestamp } from '@/lib/utils'
import { 
  TranscriptionSettings, 
  TranscriptionData, 
  SummaryData,
  SUPPORTED_LANGUAGES,
  DEFAULT_SETTINGS 
} from '@/types'
import { 
  Mic, 
  MicOff, 
  Download, 
  Settings, 
  FileText,
  Loader2,
  Monitor
} from 'lucide-react'

export function SidePanel() {
  const [settings, setSettings] = useState<TranscriptionSettings>(DEFAULT_SETTINGS)
  const [transcriptions, setTranscriptions] = useState<TranscriptionData[]>([])
  const [currentTranscription, setCurrentTranscription] = useState<string>('')
  const [summary, setSummary] = useState<string>('')
  const [isLoadingSummary, setIsLoadingSummary] = useState(false)
  const [debugInfo, setDebugInfo] = useState<string>('')

  // Add debug logging
  useEffect(() => {
    console.log('SidePanel component mounted')
    setDebugInfo('Component initialized at ' + new Date().toLocaleTimeString())
  }, [])

  const { 
    isRecording, 
    isLoading, 
    error, 
    startRecording, 
    stopRecording 
  } = useAudioRecording({
    onTranscription: handleNewTranscription,
    language: settings.targetLanguage,
    audioSource: settings.audioSource
  })

  // Load settings and transcriptions on mount
  useEffect(() => {
    loadStorageData()
  }, [])

  const loadStorageData = async () => {
    try {
      const data = await chrome.storage.local.get(['settings', 'transcriptions'])
      if (data.settings) {
        setSettings(data.settings)
      }
      if (data.transcriptions) {
        setTranscriptions(data.transcriptions)
        // Set current transcription to the latest one
        if (data.transcriptions.length > 0) {
          setCurrentTranscription(data.transcriptions[data.transcriptions.length - 1].text)
        }
      }
    } catch (error) {
      console.error('Error loading storage data:', error)
    }
  }

  const saveSettings = async (newSettings: TranscriptionSettings) => {
    try {
      await chrome.storage.local.set({ settings: newSettings })
      setSettings(newSettings)
    } catch (error) {
      console.error('Error saving settings:', error)
    }
  }

  function handleNewTranscription(transcription: TranscriptionData) {
    const updatedTranscriptions = [...transcriptions, transcription]
    setTranscriptions(updatedTranscriptions)
    setCurrentTranscription(prev => prev + ' ' + transcription.text)
    
    // Save to storage
    chrome.storage.local.set({ transcriptions: updatedTranscriptions })
  }

  const handleStartRecording = () => {
    console.log('Start recording clicked')
    setCurrentTranscription('')
    setSummary('')
    setDebugInfo(`Recording started at ${new Date().toLocaleTimeString()}`)
    startRecording()
  }

  const handleLanguageChange = (language: string) => {
    console.log('Language changed to:', language)
    const newSettings = { ...settings, targetLanguage: language }
    saveSettings(newSettings)
    setSettings(newSettings)
    setDebugInfo(`Language changed to ${language} at ${new Date().toLocaleTimeString()}`)
  }

  const handleAudioSourceChange = (audioSource: 'microphone' | 'tab') => {
    console.log('Audio source changed to:', audioSource)
    const newSettings = { ...settings, audioSource }
    saveSettings(newSettings)
    // Force a re-render to show the change immediately
    setSettings(newSettings)
    setDebugInfo(`Audio source changed to ${audioSource} at ${new Date().toLocaleTimeString()}`)
  }

  const handleDownload = () => {
    if (currentTranscription.trim()) {
      const filename = `transcription_${formatTimestamp()}.txt`
      downloadTextAsFile(currentTranscription, filename)
    }
  }

  const handleSummarize = async () => {
    if (!currentTranscription.trim()) return
    
    setIsLoadingSummary(true)
    try {
      // Mock summarization - in a real implementation, you would call an AI service
      await new Promise(resolve => setTimeout(resolve, 2000))
      
      const mockSummary = "This is a mock summary of the transcribed text. In a real implementation, this would be generated by an AI model like GPT or Claude."
      
      setSummary(mockSummary)
      
      // Save summary to storage
      const summaryData: SummaryData = {
        id: crypto.randomUUID(),
        originalTranscriptionId: transcriptions[transcriptions.length - 1]?.id || '',
        summary: mockSummary,
        timestamp: new Date()
      }
      
      const existingData = await chrome.storage.local.get(['summaries'])
      const summaries = existingData.summaries || []
      await chrome.storage.local.set({ summaries: [...summaries, summaryData] })
      
    } catch (error) {
      console.error('Error generating summary:', error)
    } finally {
      setIsLoadingSummary(false)
    }
  }

  const openOptionsPage = () => {
    chrome.runtime.openOptionsPage()
  }

  return (
    <div className="w-full max-w-md mx-auto p-4 space-y-4">
      <div className="flex items-center justify-between border-b pb-3">
        <h1 className="text-xl font-semibold">AI Live Transcriber</h1>
        <Button
          variant="ghost"
          size="icon"
          onClick={openOptionsPage}
          title="Open Settings"
        >
          <Settings className="h-4 w-4" />
        </Button>
      </div>

      {/* Language Selection */}
      <div className="space-y-2">
        <label className="text-sm font-medium">Target Language</label>
        <Select
          value={settings.targetLanguage}
          onChange={(e) => handleLanguageChange(e.target.value)}
        >
          {SUPPORTED_LANGUAGES.map((lang) => (
            <option key={lang.code} value={lang.code}>
              {lang.name}
            </option>
          ))}
        </Select>
      </div>

      {/* Audio Source Selection */}
      <div className="space-y-2">
        <label className="text-sm font-medium">Audio Source</label>
        <div className="flex gap-2">
          <Button
            variant={settings.audioSource === 'microphone' ? 'default' : 'outline'}
            size="sm"
            onClick={() => handleAudioSourceChange('microphone')}
            className="flex-1"
          >
            <Mic className="h-4 w-4 mr-2" />
            Microphone
          </Button>
          <Button
            variant={settings.audioSource === 'tab' ? 'default' : 'outline'}
            size="sm"
            onClick={() => handleAudioSourceChange('tab')}
            className="flex-1"
          >
            <Monitor className="h-4 w-4 mr-2" />
            Tab Audio
          </Button>
        </div>
      </div>

      {/* Recording Controls */}
      <div className="flex gap-2">
        {!isRecording ? (
          <Button
            onClick={handleStartRecording}
            disabled={isLoading}
            className="flex-1"
          >
            {isLoading ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <Mic className="h-4 w-4 mr-2" />
            )}
            Start Recording
          </Button>
        ) : (
          <Button
            onClick={stopRecording}
            variant="destructive"
            className="flex-1"
          >
            <MicOff className="h-4 w-4 mr-2" />
            Stop Recording
          </Button>
        )}
      </div>

      {/* Recording Status */}
      {isRecording && (
        <div className="flex items-center justify-center p-3 bg-red-50 border border-red-200 rounded-md">
          <div className="flex items-center space-x-2">
            <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>
            <span className="text-sm text-red-700">Recording in progress...</span>
          </div>
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div className="p-3 bg-red-50 border border-red-200 rounded-md">
          <p className="text-sm text-red-700">{error}</p>
        </div>
      )}

      {/* Transcription Display */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <label className="text-sm font-medium">Transcription</label>
          <div className="flex gap-1">
            <Button
              variant="ghost"
              size="sm"
              onClick={handleDownload}
              disabled={!currentTranscription.trim()}
              title="Download as file"
            >
              <Download className="h-4 w-4" />
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={handleSummarize}
              disabled={!currentTranscription.trim() || isLoadingSummary}
              title="Summarize text"
            >
              {isLoadingSummary ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <FileText className="h-4 w-4" />
              )}
            </Button>
          </div>
        </div>
        <Textarea
          value={currentTranscription}
          onChange={(e) => setCurrentTranscription(e.target.value)}
          placeholder="Transcribed text will appear here..."
          className="min-h-[120px] resize-none"
          readOnly={isRecording}
        />
      </div>

      {/* Summary Display */}
      {summary && (
        <div className="space-y-2">
          <label className="text-sm font-medium">Summary</label>
          <Textarea
            value={summary}
            readOnly
            className="min-h-[80px] resize-none bg-gray-50"
          />
        </div>
      )}

      {/* Debug Info */}
      {debugInfo && (
        <div className="pt-3 border-t">
          <div className="text-xs text-blue-600 bg-blue-50 p-2 rounded">
            <strong>Debug:</strong> {debugInfo}
          </div>
        </div>
      )}

      {/* Statistics */}
      {transcriptions.length > 0 && (
        <div className="pt-3 border-t">
          <div className="text-xs text-gray-500 space-y-1">
            <div>Total transcriptions: {transcriptions.length}</div>
            <div>
              Last session: {transcriptions[transcriptions.length - 1]?.timestamp.toLocaleString()}
            </div>
          </div>
        </div>
      )}
    </div>
  )
}